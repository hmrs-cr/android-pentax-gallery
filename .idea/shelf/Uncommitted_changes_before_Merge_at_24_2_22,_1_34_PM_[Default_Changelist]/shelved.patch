Index: app/src/main/java/com/hmsoft/pentaxgallery/ui/ImageGridFragment.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * Modified by hmrs.cr\n *\n */\n\npackage com.hmsoft.pentaxgallery.ui;\n\nimport android.annotation.SuppressLint;\nimport android.app.Activity;\nimport android.app.ActivityOptions;\nimport android.app.AlertDialog;\nimport android.app.SearchManager;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.database.Cursor;\nimport android.graphics.Point;\nimport android.graphics.drawable.BitmapDrawable;\nimport android.graphics.drawable.Drawable;\nimport android.net.Uri;\nimport android.os.AsyncTask;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.provider.MediaStore;\nimport android.provider.Settings;\nimport android.text.Html;\nimport android.text.TextUtils;\nimport android.util.TypedValue;\nimport android.view.Display;\nimport android.view.LayoutInflater;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.ViewGroup.LayoutParams;\nimport android.view.ViewTreeObserver;\nimport android.view.Window;\nimport android.view.WindowInsets;\nimport android.view.WindowManager;\nimport android.widget.AbsListView;\nimport android.widget.AdapterView;\nimport android.widget.BaseAdapter;\nimport android.widget.FrameLayout;\nimport android.widget.GridView;\nimport android.widget.ImageView;\nimport android.widget.ProgressBar;\nimport android.widget.SearchView;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\nimport com.google.android.material.floatingactionbutton.FloatingActionButton;\nimport com.hmsoft.pentaxgallery.BuildConfig;\nimport com.hmsoft.pentaxgallery.R;\nimport com.hmsoft.pentaxgallery.camera.Camera;\nimport com.hmsoft.pentaxgallery.camera.controller.CameraController;\nimport com.hmsoft.pentaxgallery.camera.model.CameraChange;\nimport com.hmsoft.pentaxgallery.camera.model.CameraData;\nimport com.hmsoft.pentaxgallery.camera.model.FilteredImageList;\nimport com.hmsoft.pentaxgallery.camera.model.ImageData;\nimport com.hmsoft.pentaxgallery.camera.model.ImageList;\nimport com.hmsoft.pentaxgallery.camera.model.StorageData;\nimport com.hmsoft.pentaxgallery.service.DownloadService;\nimport com.hmsoft.pentaxgallery.ui.camera.CameraActivity;\nimport com.hmsoft.pentaxgallery.ui.preferences.PreferencesActivity;\nimport com.hmsoft.pentaxgallery.ui.widgets.ImageThumbWidget;\nimport com.hmsoft.pentaxgallery.util.Logger;\nimport com.hmsoft.pentaxgallery.util.TaskExecutor;\nimport com.hmsoft.pentaxgallery.util.Utils;\nimport com.hmsoft.pentaxgallery.util.image.ImageCache;\nimport com.hmsoft.pentaxgallery.util.image.ImageFetcher;\nimport com.hmsoft.pentaxgallery.util.image.ImageRotatorFetcher;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport androidx.appcompat.app.ActionBar;\nimport androidx.appcompat.app.AppCompatActivity;\nimport androidx.core.view.MenuCompat;\nimport androidx.fragment.app.Fragment;\nimport androidx.swiperefreshlayout.widget.SwipeRefreshLayout;\n\n/**\n * The main fragment that powers the ImageGridActivity screen. Fairly straight forward GridView\n * implementation with the key addition being the UrlImageWorker class w/ImageCache to load children\n * asynchronously, keeping the UI nice and smooth and caching thumbnails for quick retrieval. The\n * cache is retained over configuration changes like orientation change so the images are populated\n * quickly if, for example, the user rotates the device.\n */\npublic class ImageGridFragment extends Fragment implements AdapterView.OnItemClickListener,\n        AdapterView.OnItemLongClickListener,\n        DownloadService.OnDownloadFinishedListener,\n        SearchView.OnQueryTextListener,\n        ActionBar.OnNavigationListener,\n        SwipeRefreshLayout.OnRefreshListener,\n        CameraController.OnCameraChangeListener,\n        SearchView.OnCloseListener, View.OnApplyWindowInsetsListener {\n    private static final String TAG = \"ImageGridFragment\";\n    private static final String IMAGE_CACHE_DIR = \"thumbs\";\n\n    private static ImageListTask mImageListTask = null;\n\n    private int mRequestCount = 5;\n    private int mImageThumbSize;\n    private int mImageThumbSpacing;\n    private ImageAdapter mAdapter;\n    private ImageFetcher mImageFetcher;\n    private ProgressBar mProgressBar;\n    private TextView mEmptyViewLabel;\n    private TextView mProgressLabel;\n    private GridView mGridView;\n    private FloatingActionButton mCameraActionButton;\n    private Menu mMenu;\n    private SearchView mSearchView;\n    private SwipeRefreshLayout mSwipeRefreshLayout;\n    private Camera mCamera = Camera.instance;\n    private boolean mNeedUpdateImageList;\n    private volatile boolean mDontShowProgressBar;\n\n    private final int DEFAULT_MULTIFORMAT_FILTER =  R.id.view_raw_only;\n\n    /**\n     * Empty constructor as per the Fragment documentation\n     */\n    public ImageGridFragment() {}\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setHasOptionsMenu(true);\n\n        mImageThumbSize = getResources().getDimensionPixelSize(R.dimen.image_thumbnail_size);\n        mImageThumbSpacing = getResources().getDimensionPixelSize(R.dimen.image_thumbnail_spacing);\n\n        ImageCache.ImageCacheParams cacheParams =\n                new ImageCache.ImageCacheParams(getActivity(), IMAGE_CACHE_DIR);\n\n        cacheParams.setMemCacheSizePercent(0.25f); // Set memory cache to 25% of app memory\n\n        // The ImageFetcher takes care of loading images into our ImageView children asynchronously\n        mImageFetcher = new ImageRotatorFetcher(getActivity(), mImageThumbSize);\n        mImageFetcher.setLoadingImage(R.drawable.empty_photo);\n        mImageFetcher.addImageCache(getActivity().getSupportFragmentManager(), cacheParams);\n    }\n\n    @SuppressLint(\"RestrictedApi\")\n    @Override\n    public View onCreateView(\n            LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\n\n\n        final View v = inflater.inflate(R.layout.image_grid_fragment, container, false);\n        mGridView = v.findViewById(R.id.gridView);\n        mProgressBar = v.findViewById(R.id.progressbarGrid);\n        mEmptyViewLabel = v.findViewById(R.id.emptyViewLabel);\n        mProgressLabel = v.findViewById(R.id.progressLabel);\n        mEmptyViewLabel.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                showView(false, -1);\n            }\n        });\n\n        v.setOnApplyWindowInsetsListener(this);\n\n\n        mGridView.setOnTouchListener(new View.OnTouchListener(){\n\n            @Override\n            public boolean onTouch(View v, MotionEvent event) {\n                // Disable touch while loading.\n                return mImageListTask != null;\n            }\n\n        });\n\n        mSwipeRefreshLayout = v.findViewById(R.id.swiperefresh);\n        mSwipeRefreshLayout.setOnRefreshListener(this);\n\n        mAdapter = new ImageAdapter(getActivity());\n\n        mGridView.setAdapter(mAdapter);\n        mGridView.setOnItemClickListener(this);\n        mGridView.setOnItemLongClickListener(this);\n        mGridView.setOnScrollListener(new AbsListView.OnScrollListener() {\n            @Override\n            public void onScrollStateChanged(AbsListView absListView, int scrollState) {\n                // Pause fetcher to ensure smoother scrolling when flinging\n                if (scrollState != AbsListView.OnScrollListener.SCROLL_STATE_FLING) {\n                    mImageFetcher.setPauseWork(false);\n                }\n            }\n\n            @Override\n            public void onScroll(AbsListView absListView, int firstVisibleItem,\n                    int visibleItemCount, int totalItemCount) {\n            }\n        });\n\n        // This listener is used to get the final width of the GridView and then calculate the\n        // number of columns and the width of each column. The width of each column is variable\n        // as the GridView has stretchMode=columnWidth. The column width is used to set the height\n        // of each view so we get nice square thumbnails.\n        mGridView.getViewTreeObserver().addOnGlobalLayoutListener(\n                new ViewTreeObserver.OnGlobalLayoutListener() {\n                    @Override\n                    public void onGlobalLayout() {\n                        if (mAdapter.getNumColumns() == 0) {\n                            int width = mGridView.getWidth();\n                            int numColumns = mGridView.getNumColumns();\n                            if (numColumns <= 0) {\n                                numColumns = (int) Math.floor(width / (mImageThumbSize + mImageThumbSpacing));\n                            }\n                            if (numColumns > 0) {\n                                final int columnWidth = (width / numColumns) - mImageThumbSpacing;\n                                mAdapter.setNumColumns(numColumns);\n                                mAdapter.setItemHeight(columnWidth);\n                                if (BuildConfig.DEBUG) {\n                                    Logger.debug(TAG, \"onCreateView - numColumns set to \" + numColumns);\n                                }\n                                mGridView.getViewTreeObserver()\n                                        .removeOnGlobalLayoutListener(this);\n                            }\n                        }\n                    }\n                });\n\n        mCameraActionButton = v.findViewById(R.id.cameraActionButton);\n        mCameraActionButton.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                CameraActivity.start(getActivity());\n            }\n        });\n\n        mCameraActionButton.setVisibility(mCamera.isConnected() ? View.VISIBLE : View.GONE);\n\n        updateEmptyViewText(\"\");\n\n        return v;\n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n\n        if(!Utils.hasAllPermissions()) {\n            if(mRequestCount-- < 0) {\n                Utils.showSettingActivity(getActivity());\n            } else {\n                Utils.requestAllPermissions(getActivity());\n            }\n        }\n\n        mImageFetcher.setCancel(false);\n        mImageFetcher.setExitTasksEarly(false);\n\n        ImageList imageList = mCamera.getImageList();\n\n        mCamera.rebuildFilter();\n\n        mAdapter.notifyDataSetChanged();\n\n        if(imageList == null) {\n            //syncPictureList(false);\n            loadPictureList();\n\n        } else {\n            mProgressBar.setVisibility(View.GONE);\n        }\n        DownloadService.setOnDownloadFinishedListener(this);\n        updateActionBarTitle();\n\n        DownloadService.setDisplayNotification(false);\n\n        if(mCamera.isConnected()) {\n            mCamera.getController().addCameraChangeListener(ImageGridFragment.this);\n        }\n    }\n\n    @Override\n    public void onPause() {\n        super.onPause();\n\n        if(mCamera.isConnected()) {\n            TaskExecutor.executeOnSingleThreadExecutor(new Runnable() {\n                @Override\n                public void run() {\n                    DownloadService.saveQueueToFile(mCamera.getCameraData());\n                }\n            });\n        }\n\n        mImageFetcher.setPauseWork(false);\n        mImageFetcher.setExitTasksEarly(true);\n        mImageFetcher.flushCache();\n        cancelCacheThread = true;\n\n        DownloadService.setOnDownloadFinishedListener(null);\n        DownloadService.setDisplayNotification(true);\n    }\n\n    @Override\n    public void onDestroy() {\n        mCamera.getController().removeCameraChangeListener(this);\n        if(getActivity() == null || !getActivity().isChangingConfigurations()) {\n            mCamera.getController().addCameraChangeListener(null);\n        }\n        super.onDestroy();\n        mImageFetcher.closeCache();\n        //CacheUtils.close();\n        if(mImageListTask != null) {\n            mImageListTask.cancel(true);\n            mImageListTask = null;\n        }\n    }\n\n    @Override\n    public void onItemClick(AdapterView<?> parent, View v, int position, long id) {\n        if(mAdapter.isInSelectMode()) {\n            mAdapter.toggleItemSelection(position);\n        } else {\n            startDetailActivity(v, (int) id);\n        }\n    }\n\n    @Override\n    public boolean onItemLongClick(AdapterView<?> parent, View view, int position, long id) {\n        if(mCamera.isFiltered()) {          \n            return true;\n        }\n\n        mAdapter.toggleItemSelection(position);\n        return true;\n    }\n\n    private void startDetailActivity(View v, int id) {\n        final Intent i = new Intent(getActivity(), ImageDetailActivity.class);\n        i.putExtra(ImageDetailActivity.EXTRA_IMAGE, id);\n\n        // makeThumbnailScaleUpAnimation() looks kind of ugly here as the loading spinner may\n        // show plus the thumbnail image in GridView is cropped. so using\n        // makeScaleUpAnimation() instead.\n        if(v != null) {\n            ActivityOptions options =\n                    ActivityOptions.makeScaleUpAnimation(v, 0, 0, v.getWidth(), v.getHeight());\n            getActivity().startActivity(i, options.toBundle());\n        } else {\n            getActivity().startActivity(i);\n        }\n\n    }\n\n    @Override\n    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n\n        inflater.inflate(R.menu.main_menu, menu);\n\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {\n            menu.setGroupDividerEnabled(true);\n        } else {\n            MenuCompat.setGroupDividerEnabled(menu, true);\n        }\n\n        MenuItem downloadFilter = menu.findItem(R.id.downloadFilter);\n        downloadFilter.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM);\n\n        MenuItem syncItem = menu.findItem(R.id.sync_images_1);\n        syncItem.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM);\n        syncItem = menu.findItem(R.id.sync_images_2);\n        syncItem.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM);\n        MenuItem searchItem = menu.findItem(R.id.search);\n        searchItem.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM);\n        searchItem.setActionView(R.layout.search_view);\n        MenuItem proccessDownloadQueueItem = menu.findItem(R.id.proccess_download_queue);\n        proccessDownloadQueueItem.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM);\n        MenuItem cancelDownloadQueueItem = menu.findItem(R.id.cancel_download_queue);\n        cancelDownloadQueueItem.setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);\n        MenuItem shutdownWhenDoneItem = menu.findItem(R.id.shutdown_when_download_done_queue);\n        shutdownWhenDoneItem.setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);\n\n        MenuItem downloadJpgs = menu.findItem(R.id.download_jpgs);\n        downloadJpgs.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM);\n\n        MenuItem downloadItem = menu.findItem(R.id.download_selected);\n        downloadItem.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM);\n        MenuItem clearSelectionItem = menu.findItem(R.id.clear_selection);\n        clearSelectionItem.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM);\n\n        MenuItem selectionItem = menu.findItem(R.id.select_all);\n        selectionItem.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM);\n        selectionItem = menu.findItem(R.id.select_no_downloaded);\n        selectionItem.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM);\n\n        MenuItem shareItem = menu.findItem(R.id.share);\n        shareItem.setShowAsAction(MenuItem.SHOW_AS_ACTION_ALWAYS);\n\n\n        SearchManager searchManager =\n                (SearchManager) getActivity().getSystemService(Context.SEARCH_SERVICE);\n        mSearchView =\n                (SearchView) menu.findItem(R.id.search).getActionView();\n        mSearchView.setSearchableInfo(\n                searchManager.getSearchableInfo(getActivity().getComponentName()));\n\n        mSearchView.setOnQueryTextListener(this);\n        mSearchView.setOnCloseListener(this);\n\n        mMenu = menu;\n    }\n\n    @Override\n    public void onPrepareOptionsMenu(Menu menu) {\n        super.onPrepareOptionsMenu(menu);\n        mMenu = menu;\n        updateMenuItems();\n    }\n\n    private void updateMenuItems() {\n        if(mMenu != null) {\n            if(mAdapter.isInSelectMode()) {\n                int s = mMenu.size();\n                for(int i = 0; i < s; i++) {\n                   MenuItem item = mMenu.getItem(i);\n                   int grpId = item.getGroupId();\n                   boolean visibleOnSelectMode = grpId == R.id.selection_menu_group || grpId == R.id.misc_menu_group;\n                   item.setVisible(visibleOnSelectMode);\n                }\n                return;\n            }\n\n            List<CameraData> cameras = mCamera.getRegisteredCameras();\n            if(cameras != null && cameras.size() > 1) {\n                for(CameraData cameraData : cameras) {\n                    MenuItem menuItem = mMenu.findItem(cameraData.hashCode);\n                    if(menuItem == null) {\n                        menuItem = mMenu.add(R.id.camera_menu_list, cameraData.hashCode, 1, cameraData.getDisplayName());\n                        menuItem.setCheckable(true);\n                    }\n                    CameraData currentCamera = mCamera.getCameraData();\n                    menuItem.setChecked(currentCamera != null && currentCamera.hashCode == cameraData.hashCode);\n                }\n            }\n\n            MenuItem downloadItem = mMenu.findItem(R.id.download_selected);\n            downloadItem.setVisible(false);\n            MenuItem clearSelectionItem = mMenu.findItem(R.id.clear_selection);\n            clearSelectionItem.setVisible(false);\n            MenuItem selectAllItem = mMenu.findItem(R.id.select_all);\n            selectAllItem.setVisible(false);\n            MenuItem selectNonDownloadedItem = mMenu.findItem(R.id.select_no_downloaded);\n            selectNonDownloadedItem.setVisible(false);\n\n\n            boolean isShowDownloadQueueOnly = mCamera.hasFilter(DownloadService.DownloadQueueFilter);\n            boolean isShowDownloadedOnly = mCamera.hasFilter(FilteredImageList.DownloadedFilter);\n            boolean isFlaggedOnly = mCamera.hasFilter(FilteredImageList.FlaggedFilter);\n            boolean isShowRawOnly = mCamera.hasFilter(FilteredImageList.RawFilter);\n            boolean isShowJpgOnly = mCamera.hasFilter(FilteredImageList.JpgFilter);\n\n            MenuItem downloadFilterItem = mMenu.findItem(R.id.downloadFilter);\n            downloadFilterItem.setVisible(true);\n\n            MenuItem downloadJpgs = mMenu.findItem(R.id.download_jpgs);\n            downloadJpgs.setVisible(!isShowDownloadQueueOnly);\n\n            MenuItem flaggedOnlyItem = mMenu.findItem(R.id.view_flagged_only);\n            flaggedOnlyItem.setChecked(isFlaggedOnly);\n\n            MenuItem downloadsOnlyItem = mMenu.findItem(R.id.view_downloads_only);\n            downloadsOnlyItem.setChecked(isShowDownloadQueueOnly);\n\n            MenuItem jpgsOnlyItem = mMenu.findItem(R.id.view_jpg_only);\n            jpgsOnlyItem.setChecked(isShowJpgOnly);\n            jpgsOnlyItem.setVisible(mCamera.imageListHasMixedFormats());\n\n            MenuItem rawOnlyItem = mMenu.findItem(R.id.view_raw_only);\n            rawOnlyItem.setChecked(isShowRawOnly);\n            rawOnlyItem.setVisible(mCamera.imageListHasMixedFormats());\n\n            MenuItem dowloadedOnlyItem = mMenu.findItem(R.id.view_downloaded_only);\n            dowloadedOnlyItem.setChecked(isShowDownloadedOnly);\n\n            MenuItem shareItem = mMenu.findItem(R.id.share);\n            shareItem.setVisible(isFlaggedOnly);\n\n            MenuItem searchItem = mMenu.findItem(R.id.search);\n            searchItem.setVisible(!mCamera.hasFilter(DownloadService.DownloadQueueFilter) &&\n                                  !mCamera.hasFilter(FilteredImageList.FlaggedFilter));\n\n\n            CameraData cameraData = mCamera.getCameraData();\n            boolean multyStorage =  cameraData != null && cameraData.storages.size() > 1;\n\n\n            int currentStorageIndex = mCamera.getCurrentStorageIndex();\n            String syncText = getString(R.string.sync_images);\n            MenuItem syncItem = mMenu.findItem(R.id.sync_images_1);\n            syncItem.setTitle(multyStorage ? cameraData.storages.get(0).displayName :  syncText);\n            syncItem.setVisible(!mCamera.hasFilter(DownloadService.DownloadQueueFilter));\n            syncItem.setCheckable(multyStorage);\n            syncItem.setChecked(multyStorage && currentStorageIndex == 0);\n            if(multyStorage) {\n                syncItem.setIcon(null);\n            }\n\n            syncItem = mMenu.findItem(R.id.sync_images_2);\n            syncItem.setVisible(multyStorage && !mCamera.hasFilter(DownloadService.DownloadQueueFilter));\n            syncItem.setTitle(multyStorage ? cameraData.storages.get(1).displayName :  syncText);\n            syncItem.setCheckable(multyStorage);\n            syncItem.setChecked(multyStorage && currentStorageIndex == 1);\n            if(multyStorage) {\n                syncItem.setIcon(null);\n            }\n\n            MenuItem proccessDownloadQueueItem = mMenu.findItem(R.id.proccess_download_queue);\n            proccessDownloadQueueItem.setVisible(isShowDownloadQueueOnly);\n            MenuItem cancelDownloadQueueItem = mMenu.findItem(R.id.cancel_download_queue);\n            cancelDownloadQueueItem.setVisible(isShowDownloadQueueOnly);\n            MenuItem shutdownWhenDoneItem = mMenu.findItem(R.id.shutdown_when_download_done_queue);\n            shutdownWhenDoneItem.setVisible(isShowDownloadQueueOnly);\n            shutdownWhenDoneItem.setChecked(DownloadService.shutCameraDownWhenDone());\n        }\n    }\n\n    private void removeFilters() {\n        mSearchView.setQuery(\"\", false);\n        mSearchView.setIconified(true);\n        mCamera.setImageFilter(null);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n\n        int itemId = item.getItemId();\n\n        if(mCamera.getImageList() == null) {\n            if(BuildConfig.DEBUG) Logger.debug(TAG, \"No images loaded yet.\");\n            return false;\n        }\n\n        if(item.getGroupId() == R.id.camera_menu_list) {\n            for (CameraData cameraData :  mCamera.getRegisteredCameras()) {\n                if(cameraData.hashCode == itemId) {\n                    setCurrentCamera(cameraData.cameraId);\n                    return true;\n                }\n            }\n            return true;\n        }\n\n        switch (itemId) {\n            case R.id.view_downloaded_only:\n            case R.id.view_downloads_only:\n            case R.id.view_flagged_only:\n            case R.id.view_jpg_only:\n            case R.id.view_raw_only:\n                item.setChecked(!item.isChecked());\n                showView(item.isChecked(), itemId);\n                return true;\n            case R.id.sync_images_1:\n            case R.id.sync_images_2:\n                removeFilters();\n                int currentStorageIndex = mCamera.getCurrentStorageIndex();\n                int newStorageIndex = itemId == R.id.sync_images_1 ? 0 : 1;\n                syncPictureList(newStorageIndex, currentStorageIndex != newStorageIndex,\n                        true, currentStorageIndex == newStorageIndex, null);\n                return true;\n            case R.id.shutdown_when_download_done_queue:\n                DownloadService.toggleShutCameraDownWhenDone();\n                return true;\n            case R.id.proccess_download_queue:\n                DownloadService.processDownloadQueue();\n                return true;\n            case R.id.cancel_download_queue:\n                DownloadService.cancelAllDownloads();\n                showView(false, -1);\n                return true;\n            case R.id.download_selected:\n                downloadSelected();\n                return true;\n            case R.id.clear_selection:\n                mAdapter.clearSelection();\n                return true;\n            case R.id.select_all:\n            case R.id.select_no_downloaded:\n                selectAllImages(itemId == R.id.select_no_downloaded);\n                return true;\n            case R.id.share:\n                shareFlaggedList();\n                return true;\n            case R.id.download_jpgs:\n                downloadJpgs();\n                return true;\n            case R.id.settings:\n                PreferencesActivity.start(getActivity());\n                return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    private void showView(boolean show, int itemId) {\n        if(mSearchView != null) {\n            mSearchView.setQuery(\"\", false);\n            mSearchView.setIconified(true);\n        }\n\n        mCamera.setImageFilter(null);\n        removeScreenOnFlag();\n\n        int emptyViewText = R.string.no_pictures_in_camera;\n        if(show) {\n            switch (itemId) {\n                case R.id.view_downloads_only:\n                    mCamera.setImageFilter(DownloadService.DownloadQueueFilter);\n                    if(mCamera.imageCount() > 0) {\n                        addScreenOnFlag();\n                    }\n                    emptyViewText = R.string.all_pictures_transferred;\n                    break;\n                case R.id.view_downloaded_only:\n                    mCamera.setImageFilter(FilteredImageList.DownloadedFilter);\n                    emptyViewText = R.string.no_pictures_transferred;\n                    break;\n                case R.id.view_flagged_only:\n                    mCamera.setImageFilter(FilteredImageList.FlaggedFilter);\n                    emptyViewText = R.string.no_flagged_pictures;\n                    break;\n                case R.id.view_raw_only:\n                    mCamera.setImageFilter(FilteredImageList.RawFilter);\n                    emptyViewText = R.string.no_raw_pictures;\n                    break;\n                case R.id.view_jpg_only:\n                    mCamera.setImageFilter(FilteredImageList.JpgFilter);\n                    emptyViewText = R.string.no_jpg_pictures;\n                    break;\n            }\n        } else if (itemId != DEFAULT_MULTIFORMAT_FILTER && mCamera.imageListHasMixedFormats()) {\n            showView(true, DEFAULT_MULTIFORMAT_FILTER);\n        }\n\n        updateEmptyViewText(emptyViewText);\n\n        mAdapter.notifyDataSetChanged();\n        updateMenuItems();\n        updateActionBarTitle();\n    }\n\n    private void updateProgressText(String text) {\n        if(text != null) {\n            mProgressLabel.setText(text);\n            mProgressLabel.setVisibility(View.VISIBLE);\n        } else {\n            mProgressLabel.setVisibility(View.GONE);\n        }\n        mEmptyViewLabel.setVisibility(View.GONE);\n    }\n\n    private void updateProgressText(int textId) {\n        if(textId != 0) {\n            updateProgressText(getString(textId));\n        } else {\n            updateProgressText(null);\n        }\n    }\n\n    private void updateEmptyViewText(String text) {\n        ImageList imageList = mCamera.getImageList();\n        if(imageList != null) {\n            if (imageList.length() == 0) {\n                if(text != null && text.length() > 0) {\n                    mEmptyViewLabel.setText(text);\n                } else {\n                    mEmptyViewLabel.setText(\"\");\n                }\n                mEmptyViewLabel.setVisibility(View.VISIBLE);\n                mSwipeRefreshLayout.setVisibility(View.GONE);\n            } else {\n                mEmptyViewLabel.setVisibility(View.GONE);\n                mSwipeRefreshLayout.setVisibility(View.VISIBLE);\n            }\n        }\n    }\n\n    private void updateEmptyViewText(int stringResourceId) {\n        updateEmptyViewText(getString(stringResourceId));\n    }\n\n    private void downloadJpgs() {\n        downloadJpgs(false);\n    }\n\n    /*package*/ void downloadJpgs(boolean forceRefresh) {\n\n\n        List<ImageData> enqueue = getDownloadList();\n        if ((mNeedUpdateImageList && (enqueue == null || enqueue.size() == 0)) || forceRefresh) {\n            syncPictureList(mCamera.getCurrentStorageIndex(), true, false, true,\n                    new OnRefreshDoneListener() {\n                        @Override\n                        public void onRefreshDone() {\n                            showView(true, -1);\n                            addToDownloadQueue(getDownloadList());\n                        }\n                    });\n        } else {\n            addToDownloadQueue(enqueue);\n        }\n    }\n\n    private void addToDownloadQueue(List<ImageData> enqueue) {\n        if (enqueue != null && enqueue.size() > 0) {\n            Toast.makeText(this.getActivity(), \"Transferring \" + enqueue.size() + \" pictures\", Toast.LENGTH_LONG).show();\n            DownloadService.setInBatchDownload(false);\n            for (ImageData imageData : enqueue) {\n                DownloadService.addDownloadQueue(imageData);\n            }\n            DownloadService.setInBatchDownload(true);\n            showView(true, R.id.view_downloads_only);\n        } else {\n            Toast.makeText(this.getActivity(), R.string.no_new_images_to_transfer, Toast.LENGTH_LONG).show();\n        }\n        DownloadService.processDownloadQueue();\n    }\n\n    private List<ImageData> getDownloadList() {\n        if(mCamera.isFiltered() && !mCamera.hasFilter(FilteredImageList.JpgFilter) &&\n                !mCamera.hasFilter(FilteredImageList.FlaggedFilter)) {\n            showView(false, -1);\n        }\n\n        boolean includeRaw = false;\n        ImageList imageList = mCamera.getCurrentStorage().getImageList();\n        if(mCamera.hasFilter(FilteredImageList.FlaggedFilter)) {\n            // If downloaded flagged images use only the flagged ones include raw.\n            imageList = mCamera.getImageList();\n            includeRaw = true;\n        }\n\n        List<ImageData> enqueue = new ArrayList<>();\n        if(imageList != null) {\n            for (int c = imageList.length() - 1; c >= 0; c--) {\n                ImageData imageData = imageList.getImage(c);\n                if ((includeRaw || !imageData.isRaw) && imageData.getGalleryId() == 0) {\n                    DownloadService.DownloadEntry downloadEntry = DownloadService.findDownloadEntry(imageData);\n                    if (downloadEntry == null) {\n                        enqueue.add(imageData);\n                    }\n                }\n            }\n        }\n        return  enqueue;\n    }\n\n    private void shareFlaggedList() {\n        ImageList imageList = mCamera.getImageList();\n        String text = imageList.getFlaggedList();\n\n        Intent sharingIntent = new Intent(android.content.Intent.ACTION_SEND);\n        sharingIntent.setType(\"text/plain\");\n        sharingIntent.putExtra(android.content.Intent.EXTRA_SUBJECT, R.string.flagged_images);\n        sharingIntent.putExtra(android.content.Intent.EXTRA_TEXT, text);\n        startActivity(Intent.createChooser(sharingIntent, getResources().getString(R.string.share_in)));\n    }\n\n    private void selectAllImages(boolean ignoreAlreadyDownloaded) {\n        ImageList imageList = mCamera.getImageList();\n        mAdapter.startBulkOperatio();\n        mAdapter.clearSelection();\n        for(int c = 0; c < imageList.length(); c++) {\n            ImageData imageData = imageList.getImage(c);\n            if(!ignoreAlreadyDownloaded || !imageData.existsOnLocalStorage()) {\n                mAdapter.selectItem(imageData);\n            }\n        }\n        mAdapter.finishBulkOperation();\n    }\n\n    private void downloadSelected() {\n        List<ImageData> selectedImages = mAdapter.getSelectedItems();\n        for(ImageData imageData : selectedImages) {\n            DownloadService.addDownloadQueue(imageData);\n        }\n\n        Toast.makeText (getActivity(), String.format(getString(R.string.added_to_download_queue), selectedImages.size()), Toast.LENGTH_LONG).show();\n        mAdapter.clearSelection();\n    }\n\n    private void showNoConnectedDialog(final String cameraID) {\n        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity(), android.R.style.Theme_Material_Dialog_Alert);\n\n        builder.setTitle(getString(R.string.connection_error))\n                .setMessage(Html.fromHtml(getString(R.string.camera_not_connected)))\n                .setPositiveButton(getString(R.string.wifi_settings), new DialogInterface.OnClickListener() {\n                    @Override\n                    public void onClick(DialogInterface dialog, int which) {\n                        startActivity(new Intent(Settings.ACTION_WIFI_SETTINGS));\n                    }\n                })\n                .setNegativeButton(android.R.string.cancel, new DialogInterface.OnClickListener() {\n                    @Override\n                    public void onClick(DialogInterface dialog, int which) {\n                        getActivity().finish();\n                    }\n                })\n                .setCancelable(true)\n                .setOnCancelListener(new DialogInterface.OnCancelListener() {\n                    @Override\n                    public void onCancel(DialogInterface dialog) {\n                        getActivity().finish();\n                    }\n                })\n                .setIcon(android.R.drawable.ic_dialog_alert);\n\n                if(mCamera.getRegisteredCameras().size() > 0) {\n                    builder.setNeutralButton(R.string.load_cache, new DialogInterface.OnClickListener() {\n                        @Override\n                        public void onClick(DialogInterface dialog, int which) {\n                            if (cameraID != null) {\n                                setCurrentCamera(cameraID);\n                            } else {\n                                syncPictureList(true);\n                            }\n                        }\n                    });\n                }\n\n                builder.show();\n    }\n\n    private void syncPictureList(boolean loadImageListOnly) {\n        syncPictureList(-1, loadImageListOnly, true);\n    }\n\n    private void loadPictureList() {\n        syncPictureList(-1, false, false, true, null);\n    }\n\n    private void syncPictureList(int storageIndex, boolean loadImageListOnly, boolean showProgressBar) {\n        syncPictureList(storageIndex, loadImageListOnly, showProgressBar, false, null);\n    }\n\n    private void syncPictureList(int storageIndex, boolean loadImageListOnly, boolean showProgressBar,\n                                boolean connectionNeeded, OnRefreshDoneListener refreshDoneListener) {\n        if (mImageListTask == null) {\n            if (showProgressBar) {\n                mDontShowProgressBar = false;\n                TaskExecutor.executeOnUIThread(new Runnable() {\n                    @Override\n                    public void run() {\n                        if (!mDontShowProgressBar) {\n                            mProgressBar.setVisibility(View.VISIBLE);\n                            mSwipeRefreshLayout.setVisibility(View.GONE);\n                        }\n                    }\n                }, 300);\n            }\n            mImageListTask = new ImageListTask(refreshDoneListener);\n            mImageListTask.execute(loadImageListOnly, storageIndex, null, connectionNeeded);\n        }\n    }\n\n    private void setCurrentCamera(String cameraId) {\n        if(mImageListTask == null) {\n            mProgressBar.setVisibility(View.VISIBLE);\n            mSwipeRefreshLayout.setVisibility(View.GONE);\n\n            mImageListTask = new ImageListTask(null);\n            mImageListTask.execute(false, -1, cameraId);\n        }\n    }\n\n    @Override\n    public void onDownloadFinished(ImageData imageData, long donloadId, int remainingDownloads,\n                                   int downloadCount, int errorCount, boolean wasCanceled) {\n        Logger.debug(TAG, \"onDownloadFinished: \" + donloadId + \" Remaining: \" + remainingDownloads);\n        if(mCamera.isFiltered()) {\n            if(mCamera.hasFilter(FilteredImageList.DownloadedFilter) && mCamera.getImageList() instanceof FilteredImageList) {\n                    ((FilteredImageList)mCamera.getImageList()).rebuildFilter();\n            }\n            mAdapter.notifyDataSetChanged();\n        }\n        updateActionBarTitle();\n        if(remainingDownloads == 0) {\n            if(mCamera.hasFilter(DownloadService.DownloadQueueFilter)) {\n                String viewText;\n                if(downloadCount > 0 && errorCount > 0) {\n                    viewText = String.format(getString(R.string.download_done_with_fails_notification_text),\n                            downloadCount, errorCount);\n                } else if (downloadCount > 0) {\n                    viewText = String.format(getString(R.string.download_done_notification_text), downloadCount);\n                } else if (errorCount > 0) {\n                    viewText = String.format(getString(R.string.download_done_failed_notification_text), errorCount);\n                } else {\n                    viewText = getString(R.string.all_pictures_transferred);\n                }\n                updateEmptyViewText(viewText);\n            }\n            removeScreenOnFlag();\n        }\n    }\n\n    private void removeScreenOnFlag() {\n        Window window = getActivity().getWindow();\n        int flags = window.getAttributes().flags;\n        if((flags & WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON) != 0) {\n            getActivity().getWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);\n            if (Logger.DEBUG) Logger.debug(TAG, \"removeScreenOnFlag\");\n        }\n    }\n\n    private void addScreenOnFlag() {\n        Window window = getActivity().getWindow();\n        int flags = window.getAttributes().flags;\n        if((flags & WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON) == 0) {\n            getActivity().getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);\n            if (Logger.DEBUG) Logger.debug(TAG, \"addScreenOnFlag\");\n        }\n    }\n\n    @SuppressLint(\"DefaultLocale\")\n    @Override\n    public void onDownloadProgress(ImageData imageData, long donloadId, int progress) {\n        if (mCamera.hasFilter(DownloadService.DownloadQueueFilter)) {\n            CameraData cameraData = mCamera.getCameraData();\n            if (cameraData != null) {\n                Activity activity = getActivity();\n                if (activity != null) {\n                    ActionBar actionBar = ((AppCompatActivity)getActivity()).getSupportActionBar();\n                    actionBar.setSubtitle(String.format(\"%s - %s (%d)\",\n                            imageData.fileName, progress + \"%\", mCamera.imageCount()));\n                }\n            }\n        }\n    }\n\n    @Override\n    public boolean onQueryTextSubmit(String query) {\n        mSearchView.setQuery(\"\", false);\n        mSearchView.setIconified(true);\n        if(mCamera.getImageList() != null) {\n            if(query != null && query.length() > 0) {\n                mCamera.setImageFilterText(query);\n                mAdapter.notifyDataSetChanged();\n                updateMenuItems();\n            }\n        }\n        return true;\n    }\n\n    private boolean isSearching;\n\n    @Override\n    public boolean onQueryTextChange(String newText) {\n        if(mCamera.getImageList() != null && !TextUtils.isEmpty(newText)) {\n            mCamera.setImageFilterText(newText);\n            mAdapter.notifyDataSetChanged();\n            updateMenuItems();\n            isSearching = true;\n        }\n        return false;\n    }\n\n    @Override\n    public boolean onClose() {\n        if(isSearching) {\n            TaskExecutor.executeOnUIThread(new Runnable() {\n                @Override\n                public void run() {\n                    showView(false, -1);\n                }\n            });\n            isSearching = false;\n        }\n        return false;\n    }\n\n    @Override\n    public boolean onNavigationItemSelected(int itemPosition, long itemId) {\n        return false;\n    }\n\n    @Override\n    public void onRefresh() {\n        mCamera.setCameraData(null);\n        syncPictureList(mCamera.getCurrentStorageIndex(), false, false, true, null);\n    }\n\n    @Override\n    public void onCameraChange(CameraChange change) {\n        if(change.isChanged(CameraChange.CHANGED_STORAGE)) {\n            boolean added = false;\n            if(change.filepath != null && change.filepath.length() > 0) {\n                ImageData imageData = mCamera.addImageToStorage(change.storage, change.filepath);\n                added = imageData != null;\n                if(added) {\n                    if ((imageData.isRaw && mCamera.getPreferences().autoDownloadRaw()) ||\n                            (!imageData.isRaw && mCamera.getPreferences().autoDownloadJpg())) {\n                            DownloadService.addDownloadQueue(imageData);\n                    }\n                    mAdapter.notifyDataSetChanged();\n                }\n            }\n            mNeedUpdateImageList = !added;\n        }\n        if(BuildConfig.DEBUG) Logger.debug(TAG, change.toString());\n    }\n\n    /*package*/ void rebuildCameraListMenu() {\n        if (mMenu != null) {\n            mMenu.removeGroup(R.id.camera_menu_list);\n        }\n    }\n\n    @Override\n    public WindowInsets onApplyWindowInsets(View v, WindowInsets insets) {\n        FrameLayout.LayoutParams layoutParams = (FrameLayout.LayoutParams)mCameraActionButton.getLayoutParams();\n        layoutParams.setMargins(layoutParams.leftMargin, layoutParams.topMargin,layoutParams.rightMargin,\n                layoutParams.bottomMargin + insets.getSystemWindowInsetBottom());\n        mCameraActionButton.setLayoutParams(layoutParams);\n        return insets.consumeSystemWindowInsets();\n    }\n\n    private volatile static Thread cacheThread = null;\n    private volatile boolean cancelCacheThread;\n    private void cacheThumbnails(final ImageList imageList) {\n        if (mCamera.isConnected() && cacheThread == null) {\n            cacheThread = TaskExecutor.executeOnNewThread(new Runnable() {\n                    @Override\n                    public void run() {\n                        for (int c = 0; c < imageList.length(); c++) {\n                            if(cancelCacheThread) {\n                                if(BuildConfig.DEBUG) Logger.debug(TAG, \"cancelCacheThread\");\n                                break;\n                            }\n                            ImageData imageData = imageList.getImage(c);\n                            String url = imageData.getThumbUrl();\n                            try {\n\n                                mImageFetcher.downloadUrlToCacheIfNeeded(url);\n                            } catch (Exception e) {\n                                Logger.warning(TAG, \"cacheThumbnails\", e);\n                            }\n                        }\n                        cacheThread = null;\n                        cancelCacheThread = false;\n                    }\n                });\n        } else if(BuildConfig.DEBUG && cacheThread != null) {\n            Logger.debug(TAG, \"Cache thread is running\");\n        }\n    }\n\n    /**\n     * The main adapter that backs the GridView. This is fairly standard except the number of\n     * columns in the GridView is used to create a fake top row of empty views as we use a\n     * transparent ActionBar and don't want the real top row of images to start off covered by it.\n     */\n    private class ImageAdapter extends BaseAdapter {\n\n        private final Context mContext;\n        private int mItemHeight = 0;\n        private int mNumColumns = 0;\n        private int mActionBarHeight = 0;\n        private GridView.LayoutParams mImageViewLayoutParams;\n\n        private ArrayList<ImageData> mSelectionList = new ArrayList<>();\n\n        private volatile int mBulkCount;\n\n        public ImageAdapter(Context context) {\n            super();\n            mContext = context;\n            mImageViewLayoutParams = new GridView.LayoutParams(\n                    LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);\n            // Calculate ActionBar height\n            TypedValue tv = new TypedValue();\n            if (context.getTheme().resolveAttribute(\n                    android.R.attr.actionBarSize, tv, true)) {\n\n                int statusBarHeight = 0;\n                int resourceId = getResources().getIdentifier(\"status_bar_height\", \"dimen\", \"android\");\n                if (resourceId > 0) {\n                    statusBarHeight = getResources().getDimensionPixelSize(resourceId);\n                }\n\n                mActionBarHeight = TypedValue.complexToDimensionPixelSize(\n                        tv.data, context.getResources().getDisplayMetrics()) + statusBarHeight;\n\n               mSwipeRefreshLayout.setProgressViewEndTarget(false, mActionBarHeight + 16);\n               mSwipeRefreshLayout.setProgressViewOffset(false, statusBarHeight + 8, mActionBarHeight + 8);\n            }\n        }\n\n        public void startBulkOperatio() {\n            mBulkCount++;\n        }\n\n        public boolean isInBulkOperation() {\n            return mBulkCount > 0;\n        }\n\n        public void finishBulkOperation() {\n            if(mBulkCount > 0) {\n                if(--mBulkCount == 0) {\n                    updateMenuItems();\n                    notifyDataSetChanged();\n                    updateActionBarTitle();\n                }\n            }\n        }\n\n        public void selectItem(ImageData imageData) {\n            mSelectionList.add(imageData);\n            if(!isInBulkOperation()) {\n                updateMenuItems();\n                notifyDataSetChanged();\n                updateActionBarTitle();\n            }\n        }\n        public void selectItem(int position) {\n            selectItem(getImageDataItem(position));\n        }\n\n        public boolean isItemSelected(ImageData imageData) {\n            return mSelectionList.contains(imageData);\n        }\n\n        public boolean isItemSelected(int position) {\n            return isItemSelected(getImageDataItem(position));\n        }\n\n        public void toggleItemSelection(ImageData imageData) {\n            if(isItemSelected(imageData)) {\n                removeItemFromSelection(imageData);\n            } else {\n                selectItem(imageData);\n            }\n        }\n\n        public void toggleItemSelection(int position) {\n            if(isItemSelected(position)) {\n                removeItemFromSelection(position);\n            } else {\n                selectItem(position);\n            }\n        }\n\n        public void removeItemFromSelection(ImageData imageData) {\n            mSelectionList.remove(imageData);\n            if(!isInBulkOperation()) {\n                updateMenuItems();\n                notifyDataSetChanged();\n                updateActionBarTitle();\n            }\n        }\n\n        public void removeItemFromSelection(int position) {\n            removeItemFromSelection(getImageDataItem(position));\n        }\n\n        public void clearSelection() {\n            mSelectionList.clear();\n            if(!isInBulkOperation()) {\n                updateMenuItems();\n                notifyDataSetChanged();\n                updateActionBarTitle();\n            }\n        }\n\n        public boolean isInSelectMode() {\n            return  mSelectionList.size() > 0;\n        }\n\n        public List<ImageData> getSelectedItems() {\n            return mSelectionList;\n        }\n\n        public ImageData getImageDataItem(int position) {\n            return position < mNumColumns ?\n                    null :  mCamera.getImageList().getImage(position - mNumColumns);\n        }\n\n        @Override\n        public int getCount() {\n            // If columns have yet to be determined, return no items\n            if (getNumColumns() == 0) {\n                return 0;\n            }\n\n            // Size + number of columns for top empty row\n            return mCamera.imageCount() + mNumColumns;\n        }\n\n        @Override\n        public Object getItem(int position) {\n            ImageData imageData = getImageDataItem(position);\n            return imageData != null ? imageData.getThumbUrl() : null;\n        }\n\n        @Override\n        public long getItemId(int position) {\n            return position < mNumColumns ? 0 : position - mNumColumns;\n        }\n\n        @Override\n        public int getViewTypeCount() {\n            // Two types of views, the normal ImageView and the top row of empty views\n            return 2;\n        }\n\n        @Override\n        public int getItemViewType(int position) {\n            return (position < mNumColumns) ? 1 : 0;\n        }\n\n        @Override\n        public boolean hasStableIds() {\n            return true;\n        }\n\n        @Override\n        public View getView(int position, View convertView, ViewGroup container) {\n            //BEGIN_INCLUDE(load_gridview_item)\n            // First check if this is the top row\n            if (position < mNumColumns) {\n                if (convertView == null) {\n                    convertView = new View(mContext);\n                }\n\n                // Set empty view with height of ActionBar\n                convertView.setLayoutParams(new AbsListView.LayoutParams(\n                        LayoutParams.MATCH_PARENT, mActionBarHeight));\n                return convertView;\n            }\n\n            // Now handle the main ImageView thumbnails\n            final ImageThumbWidget imageThumb;\n            if (convertView == null) { // if it's not recycled, instantiate and initialize\n                imageThumb = new ImageThumbWidget(mContext);\n                imageThumb.init(mImageViewLayoutParams);\n            } else { // Otherwise re-use the converted view\n                imageThumb = (ImageThumbWidget) convertView;\n            }\n\n            final ImageView imageView = imageThumb.getmImageView();\n\n            // Check the height matches our calculated column width\n            if (imageView.getLayoutParams().height != mItemHeight) {\n                imageView.setLayoutParams(mImageViewLayoutParams);\n            }\n\n            // Finally load the image asynchronously into the ImageView, this also takes care of\n            // setting a placeholder image while the background thread runs\n            ImageList imageList = mCamera.getImageList();\n            final ImageData imageData = imageList.getImage(position - mNumColumns);\n            mImageFetcher.loadImage(imageData.getThumbUrl(), imageData, imageView, new ImageFetcher.OnImageLoadedListener() {\n                public void onImageLoaded(boolean success) {\n                    Drawable drawable = imageView.getDrawable();\n                    if (success && drawable instanceof BitmapDrawable) {\n                        imageData.setThumbBitmap(((BitmapDrawable) drawable).getBitmap());\n                    }\n                }\n            });\n\n            if(isItemSelected(imageData)) {\n                imageThumb.showAsSelected();\n            } else {\n                imageThumb.hideBatch();\n            }\n\n          \n            return imageThumb;\n            //END_INCLUDE(load_gridview_item)\n        }\n\n        /**\n         * Sets the item height. Useful for when we know the column width so the height can be set\n         * to match.\n         *\n         * @param height\n         */\n        public void setItemHeight(int height) {\n            if (height == mItemHeight) {\n                return;\n            }\n            mItemHeight = height;\n            mImageViewLayoutParams =\n                    new GridView.LayoutParams(LayoutParams.MATCH_PARENT, mItemHeight);\n            mImageFetcher.setImageSize(height);\n            notifyDataSetChanged();\n        }\n\n        public int getNumColumns() {\n            return mNumColumns;\n        }\n\n        public void setNumColumns(int numColumns) {\n            mNumColumns = numColumns;\n        }\n    }\n\n    private void updateActionBarTitle() {\n        CameraData cameraData = mCamera.getCameraData();\n        if(cameraData != null) {\n            Activity activity = getActivity();\n            if(activity != null) {\n                ActionBar actionBar = ((AppCompatActivity)activity).getSupportActionBar();\n                actionBar.setTitle(cameraData.getDisplayName());\n                StorageData storageData = mCamera.getCurrentStorage();\n                if(storageData.getImageList() != null) {\n                    if (mAdapter.isInSelectMode()) {\n                        actionBar.setSubtitle(String.format(\"%d SELECTED\", mAdapter.getSelectedItems().size()));\n                    } else if (mCamera.hasFilter(DownloadService.DownloadQueueFilter)) {\n                        actionBar.setSubtitle(String.format(\"DOWNLOAD QUEUE (%d)\", mCamera.imageCount()));\n                    } else if (mCamera.hasFilter(FilteredImageList.DownloadedFilter)) {\n                        actionBar.setSubtitle(String.format(\"%s (%d/%s) - Downloaded\", storageData.name, mCamera.imageCount(), storageData.format).toUpperCase());\n                    } else {\n                        actionBar.setSubtitle(String.format(\"%s (%d/%s)\", storageData.name, mCamera.imageCount(), storageData.format).toUpperCase());\n                    }\n                }\n            }\n        }\n    }\n\n    public interface OnRefreshDoneListener {\n        void onRefreshDone();\n    }\n\n    private  class ImageListTask extends AsyncTask<Object, Object, ImageList> implements Camera.OnWifiConnectionAttemptListener {\n\n        private static final int PROGRESS_CONNECTED = 0;\n        private static final int PROGRESS_CONNECTING = 1;\n        private static final int PROGRESS_LOADING_LOCAL_DATA = 2;\n        private static final int PROGRESS_LOADING_PICTURE_LIST = 3;\n\n        private OnRefreshDoneListener refreshDoneListener;\n\n        private static final String TAG = \"ImageListTask\";\n\n        public ImageListTask(OnRefreshDoneListener refreshDoneListener) {\n            this.refreshDoneListener = refreshDoneListener;\n            updateProgressText(R.string.connecting);\n        }\n\n        private void debug(String message) {\n            if (BuildConfig.DEBUG) Logger.debug(TAG, message);\n        }\n\n        @Override\n        protected void onProgressUpdate(Object... values) {\n            int progressType = (int)values[0];\n            switch (progressType) {\n                case PROGRESS_CONNECTED:\n                    CameraData cameraData = (CameraData)values[1];\n                    Toast.makeText(ImageGridFragment.this.getContext(),\n                            String.format(getString(R.string.connected_to), cameraData.model, cameraData.serialNo),\n                            Toast.LENGTH_SHORT).show();\n                    updateProgressText(R.string.loading_picture_list);\n                    updateActionBarTitle();\n                    break;\n                case PROGRESS_LOADING_PICTURE_LIST:\n                    updateProgressText(R.string.loading_picture_list);\n                    break;\n                case PROGRESS_CONNECTING:\n                    updateProgressText(String.format(getString(R.string.connecting_to), values[1]));\n                    break;\n                case PROGRESS_LOADING_LOCAL_DATA:\n                    updateProgressText(R.string.loading_local_data);\n                    break;\n\n            }\n        }\n\n        @Override\n        protected ImageList doInBackground(Object... params) {\n\n            boolean loadImageListOnly = params.length > 0 ? (Boolean) params[0] : false;\n            int newStorageIndex = params.length > 1 ? (int) params[1] : -1;\n            String cameraId = params.length > 2 && params[2] != null ? String.valueOf(params[2]) : null;\n            boolean connectionNeeded = params.length > 3 ? (Boolean) params[3] : false;\n\n            CameraData cameraData;\n            if (mCamera.getCameraData() != null && loadImageListOnly) {\n                cameraData = mCamera.getCameraData();\n                publishProgress(PROGRESS_LOADING_PICTURE_LIST, cameraData);\n            } else {\n                cameraData = mCamera.connect(cameraId, this);\n                if (mCamera.isConnected()) {\n                    publishProgress(PROGRESS_CONNECTED, cameraData);\n                }\n            }\n\n            if(connectionNeeded && !mCamera.isConnected()) {\n                return null;\n            }\n\n            ImageList imageList = null;\n            if (newStorageIndex >= 0 && newStorageIndex != mCamera.getCurrentStorageIndex()) {\n                mCamera.setCurrentStorageIndex(newStorageIndex);\n                if(loadImageListOnly) {\n                    imageList = mCamera.getCurrentStorage().getImageList();\n                    mDontShowProgressBar = imageList != null;\n                }                \n            }\n\n            if (BuildConfig.DEBUG) {\n                Logger.debug(TAG, \"Load image list START\");\n            }\n\n            boolean needToLoadLocalData = !loadImageListOnly;\n            if (mNeedUpdateImageList || imageList == null || imageList.length() == 0) {\n                imageList = mCamera.loadImageList();\n                //cacheThumbnails(imageList);\n                needToLoadLocalData = true;\n            }\n\n            if (imageList != null && needToLoadLocalData) {\n                publishProgress(PROGRESS_LOADING_LOCAL_DATA);\n\n                Map<String, String> downloadedList = loadDownloadedList(imageList);\n                for (int c = 0; c < imageList.length(); c++) {\n                    ImageData imageData = imageList.getImage(c);\n                    imageData.readData();\n\n                    String id = downloadedList.get(imageData.uniqueFileName);\n                    if (id != null) {\n                        imageData.setLocalStorageUri(Uri.withAppendedPath(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, id));\n                    }\n                }\n                downloadedList.clear();\n                DownloadService.loadQueueFromFile(imageList, cameraData);\n            }\n\n            if (BuildConfig.DEBUG) {\n                Logger.debug(TAG, \"Load image list END\");\n            }\n\n            return imageList;\n        }\n\n        private Map<String, String> loadDownloadedList(ImageList imageList) {\n            final String orderByMediaStoreCursor = MediaStore.Images.Media.DATE_TAKEN;\n            final String[] projectionMediaStoreCursor = new String[] {\n                    MediaStore.Images.Media._ID,\n                    MediaStore.Images.Media.DISPLAY_NAME\n            };\n\n            StringBuilder whereSb = new StringBuilder();\n            whereSb.append(MediaStore.Images.Media.DISPLAY_NAME);\n            whereSb.append(\" IN (\");\n            for(int c = 0; c < imageList.length(); c++) {\n                whereSb.append(\"'\");\n                whereSb.append(imageList.getImage(c).uniqueFileName);\n                whereSb.append(\"'\");\n                if(c < imageList.length() - 1) {\n                    whereSb.append(\",\");\n                }\n            }\n            whereSb.append(\")\");\n\n            Cursor cursor = MediaStore.Images.Media.query(\n                    getContext().getContentResolver(),\n                    MediaStore.Images.Media.EXTERNAL_CONTENT_URI,\n                    projectionMediaStoreCursor,\n                    whereSb.toString(),\n                    orderByMediaStoreCursor);\n\n            whereSb.setLength(0);\n\n            HashMap<String, String> table = new HashMap<>();\n\n            while(cursor.moveToNext()) {\n                int idIndex = cursor.getColumnIndex(MediaStore.Images.Media._ID);\n                int displayNameIndex = cursor.getColumnIndex(MediaStore.Images.Media.DISPLAY_NAME);\n\n                String id =  cursor.getString(idIndex);\n                String uniqueName =  cursor.getString(displayNameIndex);\n                table.put(uniqueName, id);\n            }\n\n            cursor.close();\n\n            return table;\n        }\n\n        @Override\n        protected void onPostExecute(ImageList imageList) {\n\n            String from = \"cache\";\n            String cameraDisplayName = null;\n            CameraData cameraData = mCamera.getCameraData();\n            if(cameraData != null && cameraData.model != null && mCamera.isConnected()) {\n                cameraDisplayName = cameraData.getDisplayName();\n                from = cameraDisplayName + \" \" + mCamera.getCurrentStorage().displayName;\n            }\n\n            if(mCamera.isConnected()) {\n                mCamera.getController().addCameraChangeListener(ImageGridFragment.this);\n            }\n\n            mSwipeRefreshLayout.setRefreshing(false);\n            mProgressBar.setVisibility(View.GONE);\n            mAdapter.notifyDataSetChanged();\n\n            if(imageList != null) {\n                mNeedUpdateImageList = false;\n                String msg = String.format(getString(R.string.pictures_loaded), mCamera.imageCount(), from);\n                Toast.makeText(ImageGridFragment.this.getContext(),  msg, Toast.LENGTH_LONG).show();\n                mSwipeRefreshLayout.setVisibility(View.VISIBLE);\n                mGridView.smoothScrollToPosition(0);\n                if(refreshDoneListener != null) {\n                    refreshDoneListener.onRefreshDone();\n                }\n                if(imageList.hasMixedFormats) {\n                    showView(true, DEFAULT_MULTIFORMAT_FILTER);\n                }\n                DownloadService.setShutCameraDownWhenDone(mCamera.getPreferences().shutdownAfterTransfer());\n            } else {\n                CameraData camera = mCamera.getCameraData();\n                showNoConnectedDialog(camera != null ? camera.cameraId : null);\n                mCamera.setCameraData(null);\n            }\n\n            updateActionBarTitle();\n            updateMenuItems();\n\n            mCameraActionButton.setVisibility(mCamera.isConnected() ||  BuildConfig.DEBUG ? View.VISIBLE : View.GONE);\n\n            updateProgressText(null);\n            mImageListTask = null;\n        }\n\n        @Override\n        public void onWifiConnectionAttempt(String ssid) {\n            publishProgress(PROGRESS_CONNECTING, ssid);\n        }\n    }\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/hmsoft/pentaxgallery/ui/ImageGridFragment.java b/app/src/main/java/com/hmsoft/pentaxgallery/ui/ImageGridFragment.java
--- a/app/src/main/java/com/hmsoft/pentaxgallery/ui/ImageGridFragment.java	(revision a8de76e0acbf284d737071f28b7bee12e89ed127)
+++ b/app/src/main/java/com/hmsoft/pentaxgallery/ui/ImageGridFragment.java	(date 1645728601879)
@@ -134,7 +134,7 @@
     private boolean mNeedUpdateImageList;
     private volatile boolean mDontShowProgressBar;
 
-    private final int DEFAULT_MULTIFORMAT_FILTER =  R.id.view_raw_only;
+    private final int DEFAULT_MULTIFORMAT_FILTER =  R.id.view_jpg_only;
 
     /**
      * Empty constructor as per the Fragment documentation
Index: app/build.gradle
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>apply plugin: 'com.android.application'\napply plugin: 'kotlin-android'\napply plugin: 'kotlin-android-extensions'\n\ndef versionMajor = 1\ndef versionMinor = 2\ndef verCode = 3\ndef APP_NAME = \"PentaxGallery\"\n\ndef buildTime() {\n    def date = new Date()\n    def formattedDate = date.format('yyyyMMddHHmms')\n    return formattedDate\n}\n\n\ndef versionStringBase = \"${versionMajor}.${versionMinor}.${verCode}-${buildTime()}\"\n\n\nandroid {\n    compileSdkVersion 28\n    defaultConfig {\n        applicationId \"com.hmsoft.\" + APP_NAME.toLowerCase()\n        minSdkVersion 21\n        targetSdkVersion 28\n        versionName versionStringBase\n        versionCode verCode\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n    }\n    buildTypes {\n        release {\n            minifyEnabled true\n            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n        }\n    }\n\n    android.applicationVariants.all { variant ->\n        variant.outputs.all {\n            if (variant.buildType.name == \"release\") {\n                outputFileName = APP_NAME + \"-${variant.versionName}.apk\"\n            }\n        }\n    }\n\n    lintOptions {\n        checkReleaseBuilds true\n        // Or, if you prefer, you can continue to check for errors in release builds,\n        // but continue the build even when errors are found:\n        abortOnError false\n    }\n}\n\ndependencies {\n    implementation fileTree(dir: 'libs', include: ['*.jar'])\n\n    implementation 'androidx.appcompat:appcompat:1.1.0'\n    implementation 'androidx.legacy:legacy-support-v4:1.0.0'\n    implementation 'com.google.android.material:material:1.0.0'\n    implementation 'androidx.constraintlayout:constraintlayout:1.1.3'\n    implementation(\"com.squareup.okhttp3:okhttp:4.2.0\")\n    implementation 'com.google.android.material:material:1.0.0'\n    testImplementation 'junit:junit:4.12'\n    androidTestImplementation 'androidx.test.ext:junit:1.1.1'\n    androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0'\n    implementation 'androidx.exifinterface:exifinterface:1.1.0-rc01'\n    implementation \"androidx.preference:preference:1.1.0\"\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/build.gradle b/app/build.gradle
--- a/app/build.gradle	(revision a8de76e0acbf284d737071f28b7bee12e89ed127)
+++ b/app/build.gradle	(date 1645728331309)
@@ -4,10 +4,10 @@
 
 def versionMajor = 1
 def versionMinor = 2
-def verCode = 3
+def verCode = 4
 def APP_NAME = "PentaxGallery"
 
-def buildTime() {
+static def buildTime() {
     def date = new Date()
     def formattedDate = date.format('yyyyMMddHHmms')
     return formattedDate
@@ -18,10 +18,11 @@
 
 
 android {
-    compileSdkVersion 28
+    compileSdkVersion 32
     defaultConfig {
         applicationId "com.hmsoft." + APP_NAME.toLowerCase()
         minSdkVersion 21
+        //noinspection ExpiredTargetSdkVersion
         targetSdkVersion 28
         versionName versionStringBase
         versionCode verCode
@@ -33,6 +34,10 @@
             proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
         }
     }
+    lint {
+        abortOnError false
+        checkReleaseBuilds true
+    }
 
     android.applicationVariants.all { variant ->
         variant.outputs.all {
@@ -42,26 +47,20 @@
         }
     }
 
-    lintOptions {
-        checkReleaseBuilds true
-        // Or, if you prefer, you can continue to check for errors in release builds,
-        // but continue the build even when errors are found:
-        abortOnError false
-    }
 }
 
 dependencies {
     implementation fileTree(dir: 'libs', include: ['*.jar'])
 
-    implementation 'androidx.appcompat:appcompat:1.1.0'
+    implementation 'androidx.appcompat:appcompat:1.4.1'
     implementation 'androidx.legacy:legacy-support-v4:1.0.0'
-    implementation 'com.google.android.material:material:1.0.0'
-    implementation 'androidx.constraintlayout:constraintlayout:1.1.3'
+    implementation 'com.google.android.material:material:1.5.0'
+    implementation 'androidx.constraintlayout:constraintlayout:2.1.3'
     implementation("com.squareup.okhttp3:okhttp:4.2.0")
-    implementation 'com.google.android.material:material:1.0.0'
+    implementation 'com.google.android.material:material:1.5.0'
     testImplementation 'junit:junit:4.12'
-    androidTestImplementation 'androidx.test.ext:junit:1.1.1'
-    androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0'
-    implementation 'androidx.exifinterface:exifinterface:1.1.0-rc01'
-    implementation "androidx.preference:preference:1.1.0"
+    androidTestImplementation 'androidx.test.ext:junit:1.1.3'
+    androidTestImplementation 'androidx.test.espresso:espresso-core:3.4.0'
+    implementation 'androidx.exifinterface:exifinterface:1.3.3'
+    implementation "androidx.preference:preference:1.2.0"
 }
Index: build.gradle
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// Top-level build file where you can add configuration options common to all sub-projects/modules.\n\nbuildscript {\n    ext.kotlin_version = '1.3.41'\n    repositories {\n        google()\n        jcenter()\n    }\n    dependencies {\n        classpath 'com.android.tools.build:gradle:3.5.1'\n        classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\"\n        // NOTE: Do not place your application dependencies here; they belong\n        // in the individual module build.gradle files\n    }\n}\n\nallprojects {\n    repositories {\n        google()\n        jcenter()\n    }\n}\n\ntask clean(type: Delete) {\n    delete rootProject.buildDir\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/build.gradle b/build.gradle
--- a/build.gradle	(revision a8de76e0acbf284d737071f28b7bee12e89ed127)
+++ b/build.gradle	(date 1645725868143)
@@ -7,7 +7,7 @@
         jcenter()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:3.5.1'
+        classpath 'com.android.tools.build:gradle:7.1.2'
         classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
         // NOTE: Do not place your application dependencies here; they belong
         // in the individual module build.gradle files
Index: .idea/modules.xml
===================================================================
diff --git a/.idea/modules.xml b/.idea/modules.xml
deleted file mode 100644
--- a/.idea/modules.xml	(revision a8de76e0acbf284d737071f28b7bee12e89ed127)
+++ /dev/null	(revision a8de76e0acbf284d737071f28b7bee12e89ed127)
@@ -1,9 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project version="4">
-  <component name="ProjectModuleManager">
-    <modules>
-      <module fileurl="file://$PROJECT_DIR$/app/app.iml" filepath="$PROJECT_DIR$/app/app.iml" />
-      <module fileurl="file://$PROJECT_DIR$/pentax-gallery.iml" filepath="$PROJECT_DIR$/pentax-gallery.iml" />
-    </modules>
-  </component>
-</project>
\ No newline at end of file
Index: .idea/jarRepositories.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/jarRepositories.xml b/.idea/jarRepositories.xml
new file mode 100644
--- /dev/null	(date 1645725959167)
+++ b/.idea/jarRepositories.xml	(date 1645725959167)
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="RemoteRepositoriesConfiguration">
+    <remote-repository>
+      <option name="id" value="central" />
+      <option name="name" value="Maven Central repository" />
+      <option name="url" value="https://repo1.maven.org/maven2" />
+    </remote-repository>
+    <remote-repository>
+      <option name="id" value="jboss.community" />
+      <option name="name" value="JBoss Community repository" />
+      <option name="url" value="https://repository.jboss.org/nexus/content/repositories/public/" />
+    </remote-repository>
+    <remote-repository>
+      <option name="id" value="BintrayJCenter" />
+      <option name="name" value="BintrayJCenter" />
+      <option name="url" value="https://jcenter.bintray.com/" />
+    </remote-repository>
+    <remote-repository>
+      <option name="id" value="Google" />
+      <option name="name" value="Google" />
+      <option name="url" value="https://dl.google.com/dl/android/maven2/" />
+    </remote-repository>
+  </component>
+</project>
\ No newline at end of file
Index: .idea/deploymentTargetDropDown.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/deploymentTargetDropDown.xml b/.idea/deploymentTargetDropDown.xml
new file mode 100644
--- /dev/null	(date 1645727852732)
+++ b/.idea/deploymentTargetDropDown.xml	(date 1645727852732)
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="deploymentTargetDropDown">
+    <runningDeviceTargetSelectedWithDropDown>
+      <Target>
+        <type value="RUNNING_DEVICE_TARGET" />
+        <deviceKey>
+          <Key>
+            <type value="SERIAL_NUMBER" />
+            <value value="ZF6523NCV8" />
+          </Key>
+        </deviceKey>
+      </Target>
+    </runningDeviceTargetSelectedWithDropDown>
+    <timeTargetWasSelectedWithDropDown value="2022-02-24T18:31:01.619654Z" />
+  </component>
+</project>
\ No newline at end of file
Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/misc.xml b/.idea/misc.xml
new file mode 100644
--- /dev/null	(date 1645726078362)
+++ b/.idea/misc.xml	(date 1645726078362)
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="DesignSurface">
+    <option name="filePathToZoomLevelMap">
+      <map>
+        <entry key="app/src/main/res/layout/fragment_camera.xml" value="0.15670289855072464" />
+      </map>
+    </option>
+  </component>
+  <component name="ExternalStorageConfigurationManager" enabled="true" />
+  <component name="ProjectRootManager" version="2" languageLevel="JDK_11" default="true" project-jdk-name="11" project-jdk-type="JavaSDK" />
+</project>
\ No newline at end of file
Index: .idea/compiler.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/compiler.xml b/.idea/compiler.xml
new file mode 100644
--- /dev/null	(date 1645725772521)
+++ b/.idea/compiler.xml	(date 1645725772521)
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="CompilerConfiguration">
+    <bytecodeTargetLevel target="11" />
+  </component>
+</project>
\ No newline at end of file
Index: gradle/wrapper/gradle-wrapper.properties
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#Wed Sep 11 21:55:23 CST 2019\ndistributionBase=GRADLE_USER_HOME\ndistributionPath=wrapper/dists\nzipStoreBase=GRADLE_USER_HOME\nzipStorePath=wrapper/dists\ndistributionUrl=https\\://services.gradle.org/distributions/gradle-5.4.1-all.zip\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
--- a/gradle/wrapper/gradle-wrapper.properties	(revision a8de76e0acbf284d737071f28b7bee12e89ed127)
+++ b/gradle/wrapper/gradle-wrapper.properties	(date 1645725867912)
@@ -3,4 +3,4 @@
 distributionPath=wrapper/dists
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-5.4.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-7.2-all.zip
